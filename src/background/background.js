import * as browser from 'webextension-polyfill';
import { getCurrentTimeout } from '../scripts/settings.js';

// Ê∑ªÂä†Ë∞ÉËØïÂºÄÂÖ≥
const DEBUG = {
  enabled: false  // Áîü‰∫ßÁéØÂ¢ÉÈªòËÆ§ÂÖ≥Èó≠
};

// Ê∑ªÂä†Ë∞ÉËØïÊó•ÂøóÂáΩÊï∞
function debugLog(...args) {
  if (DEBUG.enabled) {
    console.log(...args);
  }
}

function debugGroup(...args) {
  if (DEBUG.enabled) {
    console.group(...args);
  }
}

function debugGroupEnd() {
  if (DEBUG.enabled) {
    console.groupEnd();
  }
}

function debugTable(...args) {
  if (DEBUG.enabled) {
    console.table(...args);
  }
}

// Ê∑ªÂä†Ëé∑ÂèñÊú¨Âú∞ÂåñÊ∂àÊÅØÁöÑËæÖÂä©ÂáΩÊï∞
function getMessage(messageName, substitutions = null) {
    return browser.i18n.getMessage(messageName, substitutions);
}

// ÈÖçÁΩÆÂ∏∏Èáè
const CONFIG = {
  TIMEOUT: {
    DEFAULT: 15000,    // ÈªòËÆ§Ë∂ÖÊó∂Êó∂Èó¥ 15 Áßí
    MIN: 5000,         // ÊúÄÂ∞èË∂ÖÊó∂Êó∂Èó¥ 5 Áßí
    MAX: 30000         // ÊúÄÂ§ßË∂ÖÊó∂Êó∂Èó¥ 30 Áßí
  }
};

// Ê∑ªÂä† onInstalled ‰∫ã‰ª∂ÁõëÂê¨Âô®
browser.runtime.onInstalled.addListener((details) => {
  // ‰ªÖÂú®È¶ñÊ¨°ÂÆâË£ÖÊó∂ÊâìÂºÄÈ°µÈù¢
  if (details.reason === 'install') {
    browser.tabs.create({
      url: './src/index/index.html'
    });
  }
});

// ‰øùÁïôÂéüÊúâÁöÑ action ÁÇπÂáª‰∫ã‰ª∂
browser.action.onClicked.addListener((tab) => {
  browser.tabs.create({
    url: './src/index/index.html'
  });
});

// Â§ÑÁêÜ URL Ê£ÄÊü•ËØ∑Ê±Ç
browser.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === 'cancelScan') {
    // ÂèñÊ∂àÊâÄÊúâÊ¥ªÂä®ËØ∑Ê±Ç
    activeRequests.forEach(controller => controller.abort());
    activeRequests.clear();
    return;
  }
  
  if (request.type === 'checkUrl') {
    const controller = new AbortController();
    activeRequests.add(controller);
    
    checkUrl(request.url, controller.signal)
      .then(result => {
        activeRequests.delete(controller);
        sendResponse(result);
      })
      .catch(error => {
        activeRequests.delete(controller);
        sendResponse({ 
          isValid: false, 
          reason: error.message 
        });
      });
    return true;
  }
});

async function checkUrl(url, signal) {
    try {
        // Ê∑ªÂä†‰ø°Âè∑Âà∞ËØ∑Ê±Ç‰∏≠
        const controller = new AbortController();
        const localSignal = controller.signal;
        
        // Â¶ÇÊûúÂ§ñÈÉ®‰ø°Âè∑Ë¢´‰∏≠Ê≠¢Ôºå‰πü‰∏≠Ê≠¢Êú¨Âú∞ÊéßÂà∂Âô®
        signal.addEventListener('abort', () => {
            controller.abort();
        });
        
        activeRequests.add(controller);
        
        const result = await checkUrlOnce(url, localSignal);
        
        activeRequests.delete(controller);
        return result;
    } catch (error) {
        if (error.name === 'AbortError') {
            throw new Error('Request cancelled');
        }
        throw error;
    }
}

async function checkUrlOnce(url) {
  const startTime = Date.now();
  try {
    // Ëé∑ÂèñÁî®Êà∑ËÆæÁΩÆÁöÑË∂ÖÊó∂Êó∂Èó¥
    const timeout = await getCurrentTimeout();
    
    debugGroup(`üîç Checking URL: ${url}`);
    debugLog(`‚è±Ô∏è Start Time: ${new Date(startTime).toLocaleTimeString()}`);
    debugLog(`‚è±Ô∏è Timeout: ${timeout}ms`);
    
    const specialProtocols = [
      'chrome:', 'chrome-extension:', 'edge:', 'about:', 'firefox:', 'moz-extension:',
      'file:', 'data:', 'javascript:', 'brave:'
    ];

    const urlObj = new URL(url);
    if (specialProtocols.some(protocol => url.startsWith(protocol))) {
      debugLog(`üîí Special protocol detected: ${urlObj.protocol}`);
      return {
        isValid: true,
        reason: 'Special protocol URL'
      };
    }

    return new Promise((resolve, reject) => {
      let finalUrl = url;
      let isResolved = false;
      let hasResponse = false;
      let requestLog = {
        startTime,
        endTime: null,
        duration: null,
        redirects: [],
        errors: [],
        statusCode: null,
        finalUrl: null,
        attempts: 0
      };

      const logRequestResult = () => {
        requestLog.endTime = Date.now();
        requestLog.duration = requestLog.endTime - requestLog.startTime;
        
        debugLog('üìä Request Summary:');
        debugTable({
          'Duration': `${requestLog.duration}ms`,
          'Has Response': hasResponse,
          'Status Code': requestLog.statusCode,
          'Redirects': requestLog.redirects.length,
          'Errors': requestLog.errors.length,
          'Final URL': requestLog.finalUrl || url
        });

        if (requestLog.redirects.length > 0) {
          debugLog('‚Ü™Ô∏è Redirects:');
          debugTable(requestLog.redirects);
        }

        if (requestLog.errors.length > 0) {
          debugLog('‚ùå Errors:');
          debugTable(requestLog.errors);
        }
      };

      const errorListener = (details) => {
        if (isResolved) return;
        hasResponse = true;
        requestLog.errors.push({
          error: details.error,
          timestamp: Date.now(),
          timeTaken: Date.now() - startTime
        });
        
        debugLog(`‚ùå Error detected: ${details.error}`);
        
        const connectionErrors = [
          'net::ERR_SOCKET_NOT_CONNECTED',
          'net::ERR_CONNECTION_CLOSED',
          'net::ERR_CONNECTION_RESET',
          'net::ERR_CONNECTION_REFUSED',
          'net::ERR_CONNECTION_TIMED_OUT'
        ];

        const accessErrors = [
          'net::ERR_NETWORK_ACCESS_DENIED',
          'net::ERR_BLOCKED_BY_RESPONSE',
          'net::ERR_BLOCKED_BY_CLIENT',
          'net::ERR_ABORTED',
          'net::ERR_FAILED'
        ];

        const certErrors = [
          'net::ERR_CERT_COMMON_NAME_INVALID',
          'net::ERR_CERT_AUTHORITY_INVALID',
          'net::ERR_CERT_DATE_INVALID'
        ];

        if (connectionErrors.includes(details.error)) {
          const alternateUrl = new URL(url);
          alternateUrl.protocol = urlObj.protocol === 'https:' ? 'http:' : 'https:';
          debugLog(`üí° Suggestion: Try ${alternateUrl.protocol} protocol`);
          
          resolveResult({
            isValid: true,
            reason: `Connection failed, might be temporary or try ${alternateUrl.protocol.slice(0, -1)}`,
            alternateUrl: alternateUrl.toString()
          });
        }
        else if (accessErrors.includes(details.error)) {
          resolveResult({ 
            isValid: true,
            reason: 'Site blocks automated access but might be accessible in browser'
          });
        }
        else if (certErrors.includes(details.error)) {
          resolveResult({ 
            isValid: true,
            reason: 'Site has certificate issues but might be accessible'
          });
        }
        else {
          resolveResult({
            isValid: false,
            reason: details.error
          });
        }
      };

      const redirectListener = (details) => {
        hasResponse = true;
        requestLog.redirects.push({
          from: details.url,
          to: details.redirectUrl,
          timestamp: Date.now(),
          timeTaken: Date.now() - startTime
        });
        finalUrl = details.redirectUrl;
        requestLog.finalUrl = finalUrl;
        debugLog(`‚Ü™Ô∏è Redirect: ${details.url} -> ${details.redirectUrl}`);
      };

      const listener = (details) => {
        if (isResolved) return;
        hasResponse = true;
        requestLog.statusCode = details.statusCode;
        debugLog(`‚úÖ Response received: Status ${details.statusCode}`);
        
        // ‰ΩøÁî® handleStatusCode ÁöÑÁªìÊûú
        const result = handleStatusCode(details.statusCode, finalUrl || url);
        if (result) {
            if (finalUrl && finalUrl !== url) {
                result.redirectUrl = finalUrl;
                result.reason = result.reason || `Redirected to ${finalUrl}`;
            }
            resolveResult(result);
            return;
        }

        // Â¶ÇÊûú handleStatusCode Ê≤°ÊúâËøîÂõûÁªìÊûúÔºå‰ΩøÁî®ÈªòËÆ§Â§ÑÁêÜ
        resolveResult({
            isValid: false,
            reason: `HTTP Error: ${details.statusCode}`
        });
      };

      const resolveResult = (result) => {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeout);
          removeListeners();
          
          logRequestResult();
          debugGroupEnd();
          debugLog(`üèÅ Final result:`, result);
          
          resolve(result);
        }
      };

      const removeListeners = () => {
        if (!isResolved) {
          browser.webRequest.onCompleted.removeListener(listener);
          browser.webRequest.onErrorOccurred.removeListener(errorListener);
          browser.webRequest.onBeforeRedirect.removeListener(redirectListener);
        }
      };

      const urlPatterns = [
        url,
        url.replace('http://', 'https://'),
        url.replace('https://', 'http://')
      ];

      browser.webRequest.onResponseStarted.addListener(
        listener,
        { urls: urlPatterns, types: ['main_frame', 'xmlhttprequest'] }
      );

      browser.webRequest.onBeforeRedirect.addListener(
        redirectListener,
        { urls: urlPatterns, types: ['main_frame', 'xmlhttprequest'] }
      );

      browser.webRequest.onCompleted.addListener(
        listener,
        { urls: urlPatterns, types: ['main_frame', 'xmlhttprequest'] }
      );

      browser.webRequest.onErrorOccurred.addListener(
        errorListener,
        { urls: urlPatterns, types: ['main_frame', 'xmlhttprequest'] }
      );

      const controller = new AbortController();
      const signal = controller.signal;

      const timeoutId = setTimeout(() => {
        if (!isResolved) {
          const timeElapsed = Date.now() - startTime;
          debugGroup('‚ö†Ô∏è Timeout Detection:');
          debugLog(`Time elapsed: ${timeElapsed}ms`);
          debugLog(`Has any response: ${hasResponse}`);
          
          if (!hasResponse) {
            debugLog('‚ùå Request timed out with no response');
            controller.abort();
            removeListeners();
            logRequestResult();
            resolve({
              isValid: false,
              reason: 'Request Timeout'
            });
          } else {
            debugLog('‚ö†Ô∏è Request timed out but had partial response');
            logRequestResult();
            resolveResult({
              isValid: true,
              reason: 'Site is responding but slow'
            });
          }
          debugGroupEnd();
        }
      }, timeout);  // ‰ΩøÁî®Ëé∑ÂèñÂà∞ÁöÑË∂ÖÊó∂Êó∂Èó¥

      fetch(url, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          // Êõ¥Áé∞‰ª£ÁöÑ User-Agent
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.256 Safari/537.36',
          // Êé•ÂèóÁöÑÂÜÖÂÆπÁ±ªÂûã
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
          // Êé•ÂèóÁöÑÁºñÁ†ÅÊñπÂºè
          'Accept-Encoding': 'gzip, deflate, br',
          // Êé•ÂèóÁöÑËØ≠Ë®Ä
          'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7',
          // ËøûÊé•Á±ªÂûã
          'Connection': 'keep-alive',
          // Á¶ÅÁî®ÁºìÂ≠ò
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          // ÂçáÁ∫ß‰∏çÂÆâÂÖ®ËØ∑Ê±Ç
          'Upgrade-Insecure-Requests': '1',
          // ÂÆâÂÖ®Â§¥ÈÉ®
          'Sec-Fetch-Dest': 'document',
          'Sec-Fetch-Mode': 'navigate',
          'Sec-Fetch-Site': 'none',
          'Sec-Fetch-User': '?1',
          // DNT (Do Not Track)
          'DNT': '1'
        },
        mode: 'no-cors',
        cache: 'no-cache',
        credentials: 'omit',  // ‰∏çÂèëÈÄÅ cookies
        redirect: 'follow',   // Ëá™Âä®Ë∑üÈöèÈáçÂÆöÂêë
        referrerPolicy: 'no-referrer'  // ‰∏çÂèëÈÄÅ referrer
      }).then(response => {
        debugLog('üì• Fetch response received:', {
          status: response.status,
          type: response.type,
          url: response.url
        });
        hasResponse = true;
      }).catch((error) => {
        debugLog('‚ùå Fetch error:', {
          name: error.name,
          message: error.message,
          type: error.type
        });
        
        // ÂØπ‰∫é CORS Âíå‰∏Ä‰∫õÂ∏∏ËßÅÁöÑËÆøÈóÆÈôêÂà∂ÔºåËÆ§‰∏∫ÁΩëÁ´ôÊòØÊúâÊïàÁöÑ
        if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
          resolveResult({
            isValid: true,
            reason: 'Site blocks automated access but might be accessible in browser'
          });
        }
        // ÂÖ∂‰ªñÈîôËØØÁªßÁª≠Á≠âÂæÖ browser.webRequest ÁöÑÁªìÊûú
      });
    });
  } catch (error) {
    debugLog(`‚ùå URL parsing error:`, error);
    return {
      isValid: false,
      reason: 'Invalid URL format'
    };
  } finally {
    debugGroupEnd();
  }
}

function getStatusCodeReason(code) {
    const reasons = {
        401: 'Requires authentication',
        403: 'Access restricted',
        429: 'Too many requests'
    };
    return reasons[code] || `Status code: ${code}`;
}

function handleStatusCode(statusCode, url) {
    // 2xx Âíå 3xx ÈÉΩËÆ§‰∏∫ÊòØÊúâÊïàÁöÑ
    if (statusCode >= 200 && statusCode < 400) {
        return { isValid: true };
    }
    
    // 4xx ‰∏≠ÁöÑ‰∏Ä‰∫õÁä∂ÊÄÅÁ†ÅË°®Á§∫ËµÑÊ∫êÂ≠òÂú®‰ΩÜËÆøÈóÆÂèóÈôê
    if ([401, 403, 429, 405, 406, 407, 408].includes(statusCode)) {
        return { 
            isValid: true,
            reason: getStatusCodeReason(statusCode)
        };
    }
    
    // Âå∫ÂàÜ‰∏çÂêåÁ±ªÂûãÁöÑ 5xx ÈîôËØØ
    if (statusCode >= 500) {
        switch (statusCode) {
            case 503: // Service Unavailable
            case 504: // Gateway Timeout
                return {
                    isValid: true,
                    reason: ('errorType_temporaryError', 'Service temporarily unavailable')
                };
                
            case 501: // Not Implemented
                return {
                    isValid: false,
                    reason: getMessage('errorType_notImplemented', 'Service not implemented')
                };
                
            case 502: // Bad Gateway
                return {
                    isValid: true,
                    reason: getMessage('errorType_badGateway', 'Bad Gateway')
                };
                
            default: // 500 ÂíåÂÖ∂‰ªñ 5xx
                return {
                    isValid: false,
                    reason: getMessage('errorType_serverError', 'Server Error')
                };
        }
    }

    return null;
}

// Ê∏ÖÁêÜ URL ÁöÑËæÖÂä©ÂáΩÊï∞
function cleanupUrl(url) {
  try {
    const urlObj = new URL(url);
    
    // 1. ÁßªÈô§Êú´Â∞æÁöÑ # Êàñ /#
    if (urlObj.hash === '#' || urlObj.hash === '') {
      url = url.replace(/#$/, '');
      url = url.replace(/\/#$/, '/');
    }
    
    // 2. Â§ÑÁêÜÈáçÂ§çÁöÑÊñúÊù†
    url = url.replace(/([^:]\/)\/+/g, '$1');
    
    // 3. Á°Æ‰øù http/https URL Êú´Â∞æÊúâÊñúÊù†
    if (!url.endsWith('/') && !urlObj.pathname.includes('.') && !urlObj.hash && !urlObj.search) {
      url += '/';
    }
    
    return url;
  } catch (e) {
    return url;
  }
}

// Ê£ÄÊµãÊòØÂê¶‰∏∫ÂçïÈ°µÈù¢Â∫îÁî® URL Ê®°Âºè
function isSPAUrl(url) {
  try {
    const urlObj = new URL(url);
    
    // 1. Ê£ÄÊü•ÊòØÂê¶‰∏∫Â∏∏ËßÅÁöÑ SPA Ë∑ØÁî±Ê®°Âºè
    const spaPatterns = [
      /\/#\//, // Vue/React Â∏∏ËßÅË∑ØÁî±Ê†ºÂºè
      /\/[#!]$/, // Angular ÂíåÂÖ∂‰ªñÊ°ÜÊû∂Â∏∏ËßÅÊ†ºÂºè
      /\/[#!]\//, // Â∏¶Ë∑ØÂæÑÁöÑ hash Ë∑ØÁî±
    ];
    
    if (spaPatterns.some(pattern => pattern.test(url))) {
      return true;
    }
    
    // 2. Ê£ÄÊü•ÊòØÂê¶‰∏∫Á∫Ø hash Ë∑ØÁî±
    if (urlObj.hash && urlObj.hash !== '#') {
      return true;
    }
    
    return false;
  } catch (e) {
    return false;
  }
}

let activeRequests = new Set();